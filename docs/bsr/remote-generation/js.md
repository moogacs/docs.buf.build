---
id: js
title: JavaScript/TypeScript
---

import Breaking from "@site/src/components/Breaking";

<Breaking 
  feature="Remote code generation for JavaScript and TypeScript"
  version="alpha"
/>

The [Buf Schema Registry](../../bsr/overview.md) (BSR) supports [remote code generation](../overview.md) for [JavaScript] and [TypeScript]. With this feature, you can push [Buf modules][modules] to the BSR and install code stubs generated from those modules using dependency management tools like [npm] and [Yarn]. JavaScript and TypeScript source code generated by the BSR is hosted on the BSR's [npm registry][npm-registry] at `npm.buf.build`.

With this feature, you no longer need to maintain Protobuf files or runtime dependencies like [protoc] plugins&mdash;in fact, JavaScript and TypeScript developers can avoid local code generation altogether for any Buf modules that have been pushed to the BSR.

## Setup

npm is configured to use the public npm registry at [registry.npmjs.org][npm-registry] by default. To configure npm to use Buf's npm registry at [npm.buf.build][buf-npm] in addition to the default registry, use this command to [set][npm-config] your npm config:

```terminal
$ npm config set @buf:registry https://npm.buf.build
```

This binds the `@buf` package scope to the BSR and updates your global [`.npmrc`][npmrc] accordingly.

## Installing packages {#install}

With your npm config set, you can install `@buf/*` packages in any standard npm project. Here's an example installation command:

```terminal
$ npm install @buf/protocolbuffers_js_acme_paymentapis
```

:::info Slow installation?
You may notice that installing packages from the BSR npm registry using `npm install` can take longer than installing from the standard npm registry. This happens because packages are generated "on the fly"&mdash;that is, they're built upon request and then cached. The first `npm install` typically takes longer than subsequent requests.
:::

## Package names

The BSR npm registry has a special syntax for package names that you need to adhere to when installing packages:

import Syntax from "@site/src/components/Syntax";

<Syntax
  title="Syntax for BSR npm registry package names"
  examples={["@buf/protocolbuffers_js_acme_petapis"]}
  segments={[
    {label: "@buf", kind: "constant"},
    {separator: "/"},
    {label: "templateOwner", kind: "variable", href: "/bsr/remote-generation/overview#templates"},
    {separator: "_"},
    {label: "templateName", kind: "variable", href: "/bsr/remote-generation/overview#templates"},
    {separator: "_"},
    {label: "moduleOwner", kind: "variable", href: "/bsr/overview#modules"},
    {separator: "_"},
    {label: "moduleName", kind: "variable", href: "/bsr/overview#modules"},
  ]
} />

In this example, the BSR npm registry generates the `@buf/protocolbuffers_js_acme_petapis` package applying the [`protocolbuffers/js`](https://buf.build/protocolbuffers/templates/js) template to the [`acme/petapis`](https://buf.build/acme/petapis) module.

This table shows some example template/module/package name combinations:

Template | Buf module | Package name
:--------|:-----------|:------------
`grpc/web` | `acme/petapis` | `@buf/grpc_web_acme_petapis`
`protocolbuffers/js` | `bufbuild/buf` | `@buf/protocolbuffers_js_bufbuild_buf`
`protocolbuffers/js` | `acme/paymentapis` | `@buf/protocolbuffers_js_acme_paymentapis`

## Using private packages {#private}

To install npm packages generated from private [Buf modules][modules], you need to configure npm to send an authentication token with each request to the BSR npm registry. Add a line with this syntax to your [`.npmrc`][npmrc] file:

<Syntax
  title="npmrc token syntax"
  examples={["//npm.buf.build/:_authToken=84612b6cbe8f4..."]}
  segments={[
    {separator: "//"},
    {label: "npm.buf.build", kind: "constant"},
    {separator: "/:"},
    {label: "_authToken", kind: "constant"},
    {separator: "="},
    {label: "token", kind: "variable"},
  ]}
/>

You can use an existing auth token or generate a new one. To create a new one, log into the [BSR], navigate to your [user settings][settings] page, and click **Create Token**.

## Other package managers

Because the Buf npm registry implements npm's [public registry API][registry-api], you should be able to use it with package management tools outside of npm, such as [Yarn] and [pnpm], though with [some known limitations](#yarn).

## Known limitations

The BSR npm registry has a few limitations that you should be aware of.

### Yarn compatibility {#yarn}

[Yarn] versions greater than [v1.10.0][yarn_v1] and less than [v2][yarn_v2] are _not_ supported. These versions of Yarn require the `shasum` field in the dist object to be set, but the BSR can't compute a digest without generating the code for all possible versions of the package.

### Runtime dependencies

If you're [creating your own plugins](../remote-generation/plugin-example.md), you can use [labels] to declare runtime dependencies for plugins. The BSR npm registry currently supports [semantic versioning][semver] for versions, like `0.1.0` or `1.2.3-SNAPSHOT`,  but _not_ semver [ranges] like `>=1.2.7` or `<1.3.0`.

### Import rewrites

If the module you request has [dependencies][deps], the npm registry rewrites any relative import paths so that they point to the package with a full package name. Here's an example rewrite:

```javascript
// generated import
require("../../google/storage/v1/storage_pb.js");

// replacement
require("@buf/grpc_web_googleapis_googleapis/google/storage/v1/storage_pb.js");
```

What this means in practice is that files generated by Protobuf plugins _must_ use the same path as their `.proto` counterparts, although suffixes like `_pb` and additional file extensions are allowed. The table below shows an original Protobuf filepath (`foo/bar.proto`) and which generated filepaths would be acceptable (or not).

Proto filepath | Path of generated file | Acceptable?
:--------------|:-----------------------|:-----------
`foo/bar.proto` | `foo/bar.js` | ✅
`foo/bar.proto` | `foo/bar_pb.js` | ✅
`foo/bar.proto` | `foo/bar_pb.ts` | ✅
`foo/bar.proto` | `foo/bar_grpc.d.ts` | ✅
`foo/bar.proto` | `foo-bar.js` | ❌
`foo/bar.proto` | `some/other/path.ts` | ❌

If you're a plugin author, be sure to heed this naming structure; otherwise, consumers of your APIs are likely to experience broken imports.

[bsr]: /bsr/overview
[buf-npm]: https://npm.buf.build
[deps]: /bsr/overview#dependencies
[javascript]: https://javascript.com
[labels]: /bsr/remote-generation/plugin-example#3-prepare-the-dockerfile
[modules]: /bsr/overview#modules
[npm]: https://npmjs.org
[npm-config]: https://docs.npmjs.com/cli/v8/commands/npm-config#set
[npmrc]: https://docs.npmjs.com/cli/v8/configuring-npm/npmrc
[plugins]: /bsr/remote-generation/concepts#plugins
[protoc]: https://github.com/protocolbuffers/protobuf
[pnpm]: https://pnpm.io
[ranges]: https://docs.npmjs.com/cli/v6/using-npm/semver#ranges
[npm-registry]: https://registry.npmjs.org
[registry-api]: https://github.com/npm/registry/blob/master/docs/REGISTRY-API.md
[semver]: https://semver.org
[settings]: https://buf.build/settings/user
[template]: /bsr/remote-generation/concepts#templates
[typescript]: https://typescript.org
[yarn]: https://yarnpkg.com
[yarn_v1]: https://github.com/yarnpkg/yarn/releases/tag/v1.10.0
[yarn_v2]: https://github.com/yarnpkg/berry
